-- A program is 0 or more imports followed by
-- zero or more function declarations
PImports.       Program         ::= Import ";" Program ;
PFuncs.         Program1        ::= Declaration Program1 ;
PLast.          Program1        ::= Declaration ;
coercions Program 1 ;

-- A declaration of function definitions, imports or algebraic data types
DImport.        Import          ::= "import" Id ;
DFunc.          Declaration     ::= "function" Id ":" TypeDecls ";" [Def] ;
DData.          Declaration     ::= "datatype" TypeIdent [Id] ":=" DataTypes Deriving ;
DSyn.           Declaration     ::= "type" TypeIdent [Id] ":=" TypeSyn Deriving ;

-- The structure of type declarations for functions.
STypeDecl.      TypeDecls       ::= Type ;
MTypeDecl.      TypeDecls       ::= Type "->" TypeDecls ;
MLiTypeDecl.    TypeDecls       ::= Type "-o" TypeDecls ;

-- Function definition
DDef.           Def             ::= Id [Arg] ":=" Exp ;
DGuardsDef.     Def             ::= Id [Arg] Guards ;
terminator nonempty Def ";" ;

DArg.           Arg             ::= Pattern ;
separator Arg "" ;

DConst.         Cons            ::= "(" TypeId Id [Id] ")" ;
DConst1.        Cons            ::= TypeId ;


-- Structure of guards in function definitions
DGuards1.       Guards          ::= ":=" Exp "when" Exp Guards1 ;
DGuards2.       Guards1         ::= ":=" Exp "when" Exp Guards1 ;
DExpGuard.      Guards1         ::= ":=" Exp ;
DEmptyGuard.    Guards1         ::= ;

--Type synonyms
DTSyn1.         TypeSyn         ::= ;
DTSyn2.         TypeSyn         ::= Type TypeSyn ;
DTSyn4.         TypeSyn         ::= "(" Type Id [Id] ")" TypeSyn ;

-- The structure of algebraic data types
DDTypes1.       DataTypes       ::= DPatterns ;
DDTypes2.       DataTypes       ::= DPatterns "|" DataTypes ;

-- The structure of algebraic data types
DDTypes3.       DPatterns       ::= TypeIdent DPatterns ;
DDTypes5.       DPatterns       ::= "(" TypeIdent Id [Id] ")" DPatterns ;
DDTypes6.       DPatterns       ::= ;


-- Deriving structure, DerArg can be any TypeClass,
-- predefined or custom-made
DDeriving1.     Deriving        ::= ";" ;
DDeriving2.     Deriving        ::= "deriving" "(" [TypeId] ")" ";" ;

-- Pattern matching
PWild.          Pattern1        ::= "_" ;
PId.            Pattern1        ::= Id ;
PConstrEmp.     Pattern1        ::= TypeId ;
PLit.           Pattern1        ::= Literal ;
PEmpty.         Pattern1        ::= "[]" ;
PListPat.       Pattern1        ::= "[" ListPat "]" ;
PTuplePat.      Pattern1        ::= "(" Pattern "," Pattern ")" ;
PTruplePat.     Pattern1        ::= "(" Pattern "," Pattern "," Pattern ")" ;
PCons.          Pattern         ::= Pattern1 ":" Pattern ;
PConsConstr.    Pattern         ::= "(" TypeId Pattern [Pattern] ")" ":" Pattern ;
--_.              Pattern2        ::= "(" Pattern ")" ; This is still broken
coercions Pattern 2 ;

-- This is needed since the list definition below is space-separated
-- for use in constructors
PList.          ListPat         ::= Pattern ;
PList1.         ListPat         ::= Pattern "," ListPat ;

[].             [Pattern]       ::= ;
(:).            [Pattern]       ::= Pattern1 [Pattern] ;

-- A literal can be any predefined token type
LitInt.         Literal         ::= Integer ;
LitDouble.      Literal         ::= Double ;
LitChar.        Literal         ::= Char ;
LitString.      Literal         ::= String ;


-- Tailor-made token type for type identifiers
token TypeId upper (letter | digit | '_' | '\'')* ;
separator nonempty TypeId "," ;

-- Variable identifier token
token Id lower (letter | digit | '_' | '\'')* ;
separator Id "" ;

-- Expression types
EEnclosed.      Exp11           ::= "(" Exp ")" ;
EVar.           Exp10           ::= Id ;
ETuple.         Exp10           ::= Tuple ;
ELiteral.       Exp10           ::= Literal ;
EConst.         Exp10           ::= Cons ;
-- EListComp.      Exp10           ::= "[" Exp "|" LCPatterns "]" ;
EList.          Exp10           ::= "[" [Exp] "]" ;
EEmptyList.     Exp10           ::= "[]" ;
ELet.           Exp10           ::= LetBinding ;
EApp.           Exp9            ::= Exp9 Exp10 ;
EPow.           Exp8            ::= Exp8 "^" Exp9 ;
EMul.           Exp7            ::= Exp7 "*" Exp8 ;
EDiv.           Exp7            ::= Exp7 "/" Exp8 ;
EAdd.           Exp6            ::= Exp6 "+" Exp7 ;
ESub.           Exp6            ::= Exp6 "-" Exp7 ;
ELt.            Exp5            ::= Exp5 "<" Exp6 ;
EGt.            Exp5            ::= Exp5 ">" Exp6 ;
ELEQ.           Exp5            ::= Exp5 "<=" Exp6 ;
EGEQ.           Exp5            ::= Exp5 ">=" Exp6 ;
EEQ.            Exp4            ::= Exp4 "==" Exp5 ;
ENEQ.           Exp4            ::= Exp4 "!=" Exp5 ;
EAND.           Exp3            ::= Exp3 "&&" Exp4 ;
EOR.            Exp2            ::= Exp2 "||" Exp3 ;
ECase.          Exp1            ::= "case" Exp "of" Cases ;
EIf.            Exp1            ::= "if" Exp2 "then" Exp2 "else" Exp ;
EAbs.           Exp1            ::= "\\" Id "->" Exp ;
coercions Exp 10 ;
separator Exp "," ;

-- Structure for case expressions
ECases1.        Cases           ::= Pattern "->" Exp ";" Cases1 ;
ECases2.        Cases1          ::= Pattern "->" Exp ";" Cases1 ;
ECases3.        Cases1          ::= ;


--Fixed size tuples
Tuple2.         Tuple           ::= "(" Exp "," Exp ")" ;
Tuple3.         Tuple           ::= "(" Exp "," Exp "," Exp ")" ;

-- Structure of list comprehensions input set(s) and predicates.
-- The elements drawn from the input set are either bound
-- to an identifier or a wild-card.
{-- ELCPatterns1.   LCPatterns      ::= Pat "<-" Id ;
ELCPatterns2.   LCPatterns      ::= Pat "<-" Id "," LCPatterns ;
ELCPatterns3.   LCPatterns      ::= Pat "<-" Id "," Predicate ;
ELCPatterns4.   LCPatterns      ::= Pat "<-" "[" [Literal] "]" ;
ELCPatterns5.   LCPatterns      ::= Pat "<-" "[" [Literal] "]" "," LCPatterns ;
ELCPatterns6.   LCPatterns      ::= Pat "<-" "[" [Literal] "]" "," Predicate ; --}
separator nonempty Literal "," ;
LCPredicate.    Predicate       ::= Exp ;
LCPredicates.   Predicate       ::= Exp "," Predicate ;

-- Let bindings, this is requires an additional ';' at the very end of the binding.
ELetBinding1.   LetBinding      ::= "let" [LetBinding1] "in" Exp ";" ;
ELetBinding2.   LetBinding1     ::= Id ":=" Exp ;
terminator nonempty LetBinding1 ";" ;

-- Types, either regular or linear
TTypeId.        Type            ::= TypeIdent ;
TList.          Type            ::= "[" [Type] "]" ;
TTuple.         Type            ::= "(" [Type] ")" ;
TFun.           Type            ::= "(" Type "->" Type ")";
TLFun.          Type            ::= "(" Type "-o" Type ")" ;

separator Type "," ;

STypeIdent.     TypeIdent        ::= TypeId ;
LiTypeIdent.    TypeIdent        ::= Id ;

-- Haskell-style comments for now
comment "--" ;
comment "{-" "-}" ;
