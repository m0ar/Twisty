-- A program is 0 or more imports followed by 
-- zero or more function declarations
PImports.		Program 		::= Import ";" Program ;
PFuncs.			Program1		::= Declaration Program1 ;
PLast.			Program1		::= Declaration ;
coercions Program 1 ;

-- A declaration of function definitions, imports or algebraic data types
DImport.		Import 			::= "import" Id ;
DFunc.			Declaration		::= "function" Id ":" TypeDecls ";" [Def] ;
terminator nonempty Def ";" ;
-- Test.       Declaration     ::= "test" LType ";" ;   DOES NOT WORK!!! For testing of TypeLId
DData1.			Declaration		::= "datatype" Type [Id] ":=" NLDataTypes ;
DData2.			Declaration		::= "datatype" LType [Id] ":=" LDataTypes ;
separator Id "" ;

-- The structure of non-linear algebraic data types
DDTypes1.		NLDataTypes		::= NLDPatterns ";" ;
DDTypes2.		NLDataTypes		::= NLDPatterns "|" NLDataTypes ;

-- The structure of non-linear algebraic data types
DDTypes4.		NLDPatterns		::= Type [Id] ;
DDTypes5.		NLDPatterns		::= Type [Id] NLDPatterns ;
DDTypes6.		NLDPatterns		::= "(" Type [Id] ")" NLDPatterns ;
DDTypes7.		NLDPatterns		::= "(" Type [Id] ")" ;


-- The structure of linear algebraic data types
DDTypes8.		LDataTypes		::= LDPatterns ";" ;
DDTypes9.		LDataTypes		::= NLDPatterns ";" ;
DDTypes10.		LDataTypes		::= LDPatterns "|" LDataTypes ;
DDTypes11.		LDataTypes		::= NLDPatterns "|" LDataTypes ;

-- The structure of linear algebraic data types
DDTypes12.		LDPatterns 		::= LType [Id] ;
DDTypes13.		LDPatterns		::= LType [Id] LDPatterns ;
DDTypes14.		LDPatterns		::= "(" LType [Id] ")" LDPatterns ;
DDTypes15.		LDPatterns		::= "(" LType [Id] ")" ;


-- Function definition
DDef.			Def 			::= Id [Arg] ":=" Exp ;
DGuardsDef.		Def 			::= Id [Arg] Guards ;
separator Arg "" ;

-- Arguments can be either a literal, identifier or a list pattern
DArg1.			Arg 			::= Literal ;
DArg2.			Arg 			::= Id ;
DArg3.			Arg 			::= TypeId ;
DArg4.			Arg 			::= LiTypeId ;
DArg5.			Arg 			::= ListPattern ;
DArg6.			Arg 			::= Tuple ;
DArg7.			Arg 			::= LiTuple ;

DGuards1.		Guards			::= ":=" Exp "when" Exp Guards1 ;
DGuards2.		Guards1			::= ":=" Exp "when" Exp Guards1 ;
DExpGuard.		Guards1			::= ":=" Exp ;
DEmptyGuard.	Guards1			::= ;

-- Pattern matching for lists
LPattern1.		ListPattern 	::= "[]";
LPattern2.		ListPattern 	::= "(" Id ":" Pattern ")";
LPattern3.		Pattern 		::= "[]" ;
LPattern4.		Pattern 		::= Id ;
LPattern5.		Pattern 		::= Id ":" Pattern ;

-- A literal can be any predefined token type or a tailor-made token type
LitInt.			Literal  		::= Integer ;
LitDouble.		Literal 		::= Double ;
LitChar.		Literal 		::= Char ;
LitString.		Literal 		::= [String] ;
separator nonempty String "" ;

-- Tailor-made token type for identifiers
token Id (lower (letter | digit | '_' | '\'')*) ;

-- Tailor-made token types for type identifiers
token TypeId (upper (letter | digit | '_' | '\'')*) ;
token LiTypeId ('i' (upper (letter | digit | '_' | '\'')*)) ;

-- Expression types
EVar.			Exp10			::= Id ;
ETypeId.		Exp10			::= TypeId ;
ETypeLId.		Exp10			::= LiTypeId ;
ELiteral.		Exp10			::= Literal ;
ETuple.			Exp10			::= Tuple ;
EApp.			Exp9			::= Exp9 Exp10 ;
EPow.			Exp8			::= Exp8 "**" Exp9 ;
EMul.			Exp7			::= Exp7 "*" Exp8 ;
EDiv. 			Exp7			::= Exp7 "/" Exp8 ;
EAdd.			Exp6			::= Exp6 "+" Exp7 ;
ESub.			Exp6			::= Exp6 "-" Exp7 ;
ELt. 			Exp5			::= Exp5 "<" Exp6 ;
EGt.			Exp5			::= Exp5 ">" Exp6 ;
ELEQ.			Exp5			::= Exp5 "<=" Exp6 ;
EGEQ.			Exp5			::= Exp5 ">=" Exp6 ;
EEQ.			Exp4			::= Exp4 "==" Exp5 ;
ENEQ.			Exp4			::= Exp4 "!=" Exp5 ;
EAND.			Exp3			::= Exp3 "&&" Exp4 ;
EOR.			Exp2			::= Exp2 "||" Exp3 ;
EAbs.			Exp1 			::= "\\" Id "->" Exp ;
coercions Exp 10 ;

-- The structure of type declarations for functions.
SType.			TypeDecls		::= TypeId ;
SLiType.		TypeDecls		::= LiTypeId ;
TType.			TypeDecls		::= Tuple ;
LiTType.		TypeDecls		::= LiTuple ;
LSType.			TypeDecls		::= "[" TypeId "]" ;
LSLiType.		TypeDecls		::= "[" LiTypeId "]" ;
LSTType.		TypeDecls		::= "[" Tuple "]" ;
LSLiTType.		TypeDecls		::= "[" LiTuple "]" ;
MType.			TypeDecls		::= TypeId "->" TypeDecls ;
MTType.			TypeDecls		::= Tuple "->" TypeDecls ;
MLiType.		TypeDecls		::= LiTypeId "-o" TypeDecls ;
MTLiType.		TypeDecls		::= LiTuple "-o" TypeDecls ;
LMType.			TypeDecls		::= "[" TypeId "]" "->" TypeDecls ;
LMTType.		TypeDecls		::= "[" Tuple "]" "->" TypeDecls ;
LMLitype.		TypeDecls		::= "[" LiTypeId "]" "-o" TypeDecls ;
LMLiTtype.		TypeDecls		::= "[" LiTuple "]" "-o" TypeDecls ;


-- All the possible permutations for regular tuples that can be either 
-- of size 2 or 3, with possible nested tuples. Regular tuples cannot
-- contain linear elements.
TupleDef1.			Tuple		::= "(" TupleArgs "," TupleArgs ")" ;
TupleDef2.			Tuple		::= "(" Tuple "," TupleArgs ")" ;
TupleDef3.			Tuple		::= "(" TupleArgs "," Tuple ")" ;
TupleDef4.			Tuple		::= "(" Tuple "," Tuple ")" ;
TupleDef5.			Tuple		::= "(" TupleArgs "," TupleArgs "," TupleArgs ")" ;
TupleDef6.			Tuple		::= "(" Tuple "," TupleArgs "," TupleArgs ")" ;
TupleDef7.			Tuple		::= "(" TupleArgs "," Tuple "," TupleArgs ")" ;
TupleDef9.			Tuple		::= "(" TupleArgs "," TupleArgs "," Tuple ")" ;
TupleDef10.			Tuple		::= "(" Tuple "," Tuple "," TupleArgs ")" ;
TupleDef11.			Tuple		::= "(" TupleArgs "," Tuple "," Tuple ")" ;
TupleDef12.			Tuple		::= "(" Tuple "," TupleArgs "," Tuple ")" ;
TupleDef13.			Tuple		::= "(" Tuple "," Tuple "," Tuple ")" ;

-- Linear tuples must contain at least one linear element, with
-- the possibility of the other elements being non-linear.
LiTupleDef1.		LiTuple		::= "(" LiTypeId "," TupleArgs ")" ;
LiTupleDef2.		LiTuple		::= "(" TupleArgs "," LiTypeId ")" ;
LiTupleDef3.		LiTuple		::= "(" LiTuple "," TupleArgs ")" ;
LiTupleDef4.		LiTuple		::= "(" TupleArgs "," LiTuple ")" ;
LiTupleDef5.		LiTuple		::= "(" LiTuple "," LiTuple ")" ;
LiTupleDef6.		LiTuple		::= "(" LiTypeId "," TupleArgs "," TupleArgs ")" ;
LiTupleDef7.		LiTuple		::= "(" TupleArgs "," LiTypeId "," TupleArgs ")" ;
LiTupleDef8.		LiTuple		::= "(" TupleArgs "," TupleArgs "," LiTypeId ")" ;
LiTupleDef9.		LiTuple		::= "(" LiTuple "," TupleArgs "," TupleArgs ")" ;
LiTupleDef10.		LiTuple		::= "(" TupleArgs "," LiTuple "," TupleArgs ")" ;
LiTupleDef11.		LiTuple		::= "(" TupleArgs "," TupleArgs "," LiTuple ")" ;
LiTupleDef12.		LiTuple		::= "(" LiTuple "," LiTuple "," TupleArgs ")" ;
LiTupleDef13.		LiTuple		::= "(" LiTuple "," TupleArgs "," LiTuple ")" ;
LiTupleDef14.		LiTuple		::= "(" TupleArgs "," LiTuple "," LiTuple ")" ;
LiTupleDef15.		LiTuple		::= "(" LiTuple "," LiTuple "," LiTuple ")" ;

-- Non-linear tuple arguments
TupleArgs1.			TupleArgs	::= Id ;
TupleArgs2.			TupleArgs	::= Literal ;
TupleArgs3.			TupleArgs	::= TypeId ;

-- Linear tuple arguments
LiTupleArgs1.		LiTupleArgs	::= Id ;
LiTupleArgs2.		LiTupleArgs	::= Literal ;
LiTupleArgs3.		LiTupleArgs	::= TypeId ;
LiTupleArgs4.		LiTupleArgs	::= LiTypeId ;

-- Types, either regular or linear
TId.			Type 			::= TypeId ;
TLId.			LType 			::= LiTypeId ;

-- Haskell-style comments for now
comment "--" ;
comment "{-" "-}" ;
