-- A program is 0 or more imports followed by
-- zero or more function declarations
PImports.       Program         ::= Import ";" Program ;
PFuncs.         Program1        ::= Declaration Program1 ;
PLast.          Program1        ::= Declaration ;
coercions Program 1 ;

-- A declaration of function definitions, imports or algebraic data types
DImport.        Import          ::= "import" Id ;
DFunc.          Declaration     ::= "function" Id ":" TypeDecls ";" [Def] ;
DData.          Declaration     ::= "datatype" TypeIdent [FieldType] ":=" [DPatterns] ";" ;
separator nonempty DPatterns "|" ;
DSyn.           Declaration     ::= "type" TypeIdent [Id] ":=" TypeSyn Deriving ;
layout toplevel ;

-- The structure of type declarations for functions.
STypeDecl.      TypeDecls       ::= Type ;
MTypeDecl.      TypeDecls       ::= Type "->" TypeDecls ;
MLiTypeDecl.    TypeDecls       ::= Type "-o" TypeDecls ;

-- Function definition
DDef.           Def             ::= Id [Arg] ":=" Exp ;
DGuardsDef.     Def             ::= Id [Arg] Guards ;
terminator nonempty Def ";" ;

DArg.           Arg             ::= Pattern ;
separator Arg "" ;

DConst1.        Cons            ::= "(" TypeId Id [Id] ")" ;
DConst2.        Cons            ::= TypeId ;


-- Structure of guards in function definitions
DGuards1.       Guards          ::= ":=" Exp "when" Exp Guards1 ;
DGuards2.       Guards1         ::= ":=" Exp "when" Exp Guards1 ;
DExpGuard.      Guards1         ::= ":=" Exp ;
DEmptyGuard.    Guards1         ::= ;

--Type synonyms
DTSyn1.         TypeSyn         ::= ;
DTSyn2.         TypeSyn         ::= Type TypeSyn ;
DTSyn3.         TypeSyn         ::= "(" Type Id [Id] ")" TypeSyn ;

-- The structure of algebraic data types
DDTypes3.       DPatterns       ::= TypeIdent ;
DDTypes4.       DPatterns       ::= "(" TypeIdent FieldType [FieldType] ")" ;
separator FieldType "" ;

-- Type synonyms for id and type for use in datatypes
FieldType1.     FieldType       ::= Id ;
FieldType2.     FieldType       ::= TypeId ;

-- Deriving structure, DerArg can be any TypeClass,
-- predefined or custom-made
DDeriving1.     Deriving        ::= ";" ;
DDeriving2.     Deriving        ::= "deriving" "(" [TypeId] ")" ";" ;

-- Pattern matching
PWild.          Pattern1        ::= "_" ;
PId.            Pattern1        ::= Id ;
PConstrEmp.     Pattern1        ::= TypeId ;
PLit.           Pattern1        ::= Literal ;
PEmpty.         Pattern1        ::= "[]" ;
PListPat.       Pattern1        ::= "[" ListPat "]" ;
PTuplePat.      Pattern1        ::= "(" Pattern "," Pattern ")" ;
PTruplePat.     Pattern1        ::= "(" Pattern "," Pattern "," Pattern ")" ;
PDataConstr.    Pattern1        ::= "(" TypeIdent Pattern1 [Pattern1] ")" ;
PCons.          Pattern         ::= Pattern1 ":" Pattern ;
-- PConsConstr.    Pattern         ::= "(" TypeId Pattern [Pattern] ")" ":" Pattern ;
--_.              Pattern2        ::= "(" Pattern ")" ; This is still broken
coercions Pattern 1 ;
separator Pattern1 "" ;

-- This is needed since the list definition below is space-separated
-- for use in constructors
PList1.         ListPat         ::= Pattern ;
PList2.         ListPat         ::= Pattern "," ListPat ;

[].             [Pattern]       ::= ;
(:).            [Pattern]       ::= Pattern1 [Pattern] ;

-- A literal can be any predefined token type
LitInt.         Literal         ::= Integer ;
LitDouble.      Literal         ::= Double ;
LitChar.        Literal         ::= Char ;
LitString.      Literal         ::= String ;
separator nonempty Literal "," ;

-- Tailor-made token type for type identifiers
token TypeId upper (letter | digit | '_' | '\'')* ;
separator nonempty TypeId "," ;

-- Variable identifier token
token Id lower (letter | digit | '_' | '\'')* ;
separator Id "" ;

-- Expression types
--EEnclosed.      Exp12           ::= "(" Exp ")" ;
EVar.           Exp11           ::= Id ;
ETuple.         Exp11           ::= Tuple ;
ELiteral.       Exp11           ::= Literal ;
EConst.         Exp11           ::= Cons ;
EListComp.      Exp11           ::= "[" Exp "|" LCPatterns "]" ;
EList.          Exp11           ::= "[" [Exp] "]" ;
EEmptyList.     Exp11           ::= "[]" ;
EApp.           Exp10           ::= Exp10 Exp11 ;
ELogicalNeg.    Exp9            ::= "not" Exp10 ;
ENeg.           Exp9            ::= "-" Exp10 ;
EConcat.        Exp9            ::= Exp9 "++" Exp10 ;
ECons.          Exp9            ::= Exp9 ":" Exp10 ;
EPow.           Exp8            ::= Exp8 "^" Exp9 ;
EMul.           Exp7            ::= Exp7 "*" Exp8 ;
EDiv.           Exp7            ::= Exp7 "/" Exp8 ;
EAdd.           Exp6            ::= Exp6 "+" Exp7 ;
ESub.           Exp6            ::= Exp6 "-" Exp7 ;
ELt.            Exp5            ::= Exp5 "<" Exp6 ;
EGt.            Exp5            ::= Exp5 ">" Exp6 ;
ELEq.           Exp5            ::= Exp5 "<=" Exp6 ;
EGEq.           Exp5            ::= Exp5 ">=" Exp6 ;
EEq.            Exp4            ::= Exp4 "==" Exp5 ;
ENEq.           Exp4            ::= Exp4 "!=" Exp5 ;
EAnd.           Exp3            ::= Exp3 "&&" Exp4 ;
EOr.            Exp2            ::= Exp2 "||" Exp3 ;
ELet.           Exp1           ::= "let" Id ":=" Exp2 "in" Exp ;
EBind.          Exp1            ::= Exp2 ">>=" Exp1 ;
ESeq.           Exp1            ::= Exp2 ">>" Exp1 ;
ECase.          Exp1            ::= "case" Exp "of" "{" Cases "}" ;
EIf.            Exp1            ::= "if" Exp2 "then" Exp2 "else" Exp ;
EAbs.           Exp1            ::= "\\" Id [Id] "->" Exp ;
coercions Exp 11 ;
separator Exp "," ;

-- Structure for case expressions
ECases1.        Cases           ::= Pattern "->" Exp ";" Cases1 ;
ECases2.        Cases1          ::= Pattern "->" Exp ";" Cases1 ;
ECases3.        Cases1          ::= Pattern "->" Exp ;

--Fixed size tuples
Tuple1.         Tuple           ::= "(" Exp "," Exp ")" ;
Tuple2.         Tuple           ::= "(" Exp "," Exp "," Exp ")" ;

-- Structure of list comprehensions input set(s) and predicates.
-- The elements drawn from the input set are either bound
-- to an identifier  or a wild-card.
ELCPatterns1.   LCPatterns      ::= BoundVar "<-" InputSet ;
ELCPatterns2.   LCPatterns      ::= BoundVar "<-" InputSet "," LCPatterns ;
ELCPatterns3.   LCPatterns      ::= BoundVar "<-" InputSet "when" Exp ;

Awild.          BoundVar        ::= "_" ;
AId.            BoundVar        ::= Id ;

-- input set in list comprehensions
LInputSet1.     InputSet        ::= Id ;
LInputSet2.     InputSet        ::= "[" [Literal] "]" ;
LInputSet3.     InputSet        ::= "[" EnumElem ".." EnumElem "]" ;

-- condensed way of enumerated elements in the list comprehensions
LEnumElem1.     EnumElem        ::= Integer ;
LEnumElem2.     EnumElem        ::= Double ;
LEnumElem3.     EnumElem        ::= Char ;

-- Let bindings, this is requires an additional ';' at the very end of the binding.
-- ELetBinding1.   LetBinding      ::= "let" "{" LetBinding1 "}" "in" Exp ";" ;
-- ELetBinding2.   LetBinding1     ::= Id ":=" Exp ;
--separator nonempty LetBinding1 ";" ;

-- Types, either regular or linear
TTypeId.        Type            ::= TypeIdent ;
TList.          Type            ::= "[" [Type] "]" ;
TTuple.         Type            ::= "(" [Type] ")" ;
TFun.           Type            ::= "(" Type "->" Type ")";
TLFun.          Type            ::= "(" Type "-o" Type ")" ;

separator Type "," ;

STypeIdent.     TypeIdent       ::= TypeId ;
LiTypeIdent.    TypeIdent       ::= Id ;

-- Haskell-style comments for now
comment "--" ;
comment "{-" "-}" ;
layout toplevel ;
layout "of" ;
