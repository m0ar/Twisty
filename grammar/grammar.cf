-- A program is 0 or more imports followed by 
-- zero or more function declarations
PImports.		Program 		::= Import ";" Program ;
PFuncs.			Program1		::= Declaration Program1 ;
PLast.			Program1		::= Declaration ;
coercions Program 1 ;

-- A declaration of function definitions, imports or algebraic data types
DImport.		Import 			::= "import" Id ;
DFunc.			Declaration		::= "function" Id ":" TypeDecls ";" [Def] ;
DData.			Declaration		::= "datatype" TypeId [Id] ":=" DataTypes Deriving ;
DSyn.			Declaration		::= "type" TypeId [Id] ":=" TypeSyn Deriving ;

-- The structure of type declarations for functions.
STypeDecl.		TypeDecls		::= TDParam ;
MTypeDecl.		TypeDecls		::= TDParam "->" TypeDecls ;
MLiTypeDecl.	TypeDecls		::= TDParam "-o" TypeDecls ;

-- Type parameters for type declarations
TypeDeclParam1.	TDParam			::= Id ;
TypeDeclParam2.	TDParam			::= Type ;

-- Function definition
DDef.			Def 			::= Id [Arg] ":=" Exp ;
DGuardsDef.		Def 			::= Id [Arg] Guards ;
terminator nonempty Def ";" ;

-- Arguments in function definitions can be either a literal,
-- identifier, type (linear or non-linear), list pattern or a tuple
DArg1.			Arg 			::= Literal ;
DArg2.			Arg 			::= Id ;
DArg3.			Arg 			::= TypeId ; -- Should be type constructors, right?
DArg4.			Arg 			::= ListPattern ;
DArg5.			Arg 			::= TuplePattern ;
separator Arg "" ;


-- Structure of guards in function definitions
DGuards1.		Guards			::= ":=" Exp "when" Exp Guards1 ;
DGuards2.		Guards1			::= ":=" Exp "when" Exp Guards1 ;
DExpGuard.		Guards1			::= ":=" Exp ;
DEmptyGuard.	Guards1			::= ;

--Type synonyms
DTSyn1.         TypeSyn         ::= ;
DTSyn2.         TypeSyn         ::= Type TypeSyn ;
DTSyn3.         TypeSyn         ::= Id TypeSyn ;
DTSyn4.         TypeSyn         ::= "(" Type Id [Id] ")" TypeSyn ;

-- The structure of algebraic data types
DDTypes1.		DataTypes		::= DPatterns ;
DDTypes2.		DataTypes		::= DPatterns "|" DataTypes ;

-- The structure of algebraic data types
DDTypes3.       DPatterns       ::= TypeId DPatterns ;
DDTypes4.       DPatterns       ::= TypeId Id [Id] DPatterns ;
DDTypes5.       DPatterns       ::= "(" TypeId Id [Id] ")" DPatterns ;
DDTypes6.       DPatterns       ::= ;


-- Deriving structure
DDeriving1.		Deriving		::= ";" ;
DDeriving2.		Deriving		::= "deriving" "(" [DerArg] ")" ";" ;
separator nonempty DerArg "," ;
DDerArg1.		DerArg			::= "Show" ;
DDerArg2.		DerArg			::= "Read" ;
DDerArg3.		DerArg			::= "Eq" ;
DDerArg4.		DerArg			::= "Ord" ;
DDerArg5.		DerArg			::= "Num" ;
DDerArg6.		DerArg			::= "Integral" ;
DDerArg7.		DerArg			::= "Floating" ;
DDerArg8.		DerArg			::= "Enum" ;
DDerArg9.		DerArg			::= "Bounded" ;

-- Pattern matching for lists in function definition arguments
LPattern1.		ListPattern 	::= "[]" ;
LPattern2.		ListPattern 	::= "(" Pat ":" LPattern ")" ;
LPattern3.		LPattern 		::= "[]" ;
LPattern4.		LPattern 		::= Pat ;
LPattern5.		LPattern 		::= Pat ":" LPattern ;

TPattern1.      TuplePattern    ::= "()" ;
TPattern2.      TuplePattern    ::= "(" [Pat] ")" ;

-- categroy for every case when an underscore or an identifier is accepted
Pwild.			Pat				::= "_" ;
PId.			Pat				::= Id ;
PLit.           Pat             ::= Literal ;
separator Pat "," ;

-- A literal can be any predefined token type
LitInt.			Literal  		::= Integer ;
LitDouble.		Literal 		::= Double ;
LitChar.		Literal 		::= Char ;
LitString.		Literal 		::= String ;

-- Tailor-made token type for identifiers
token Id (lower (letter | digit | '_' | '\'')*) ;
separator Id "" ;

-- Tailor-made token types for type identifiers
token TypeId (('i' | upper) (letter | digit | '_' | '\'')*) ;

-- Expression types
EVar.			Exp10			::= Id ;
ELiteral.		Exp10			::= Literal ;
ETrue.          Exp10           ::= "true" ;
EFalse.         Exp10           ::= "false" ;
ETuple.			Exp10			::= Tuple ;
EListComp.		Exp10			::= "[" Exp "|" LCPatterns "]" ;
EList.			Exp10			::= "[" [Exp] "]" ;
ELet.			Exp10			::= LetBinding ;
EApp.			Exp9			::= Exp9 Exp10 ;
EPow.			Exp8			::= Exp8 "^" Exp9 ;
EMul.			Exp7			::= Exp7 "*" Exp8 ;
EDiv. 			Exp7			::= Exp7 "/" Exp8 ;
EAdd.			Exp6			::= Exp6 "+" Exp7 ;
ESub.			Exp6			::= Exp6 "-" Exp7 ;
ELt. 			Exp5			::= Exp5 "<" Exp6 ;
EGt.			Exp5			::= Exp5 ">" Exp6 ;
ELEQ.			Exp5			::= Exp5 "<=" Exp6 ;
EGEQ.			Exp5			::= Exp5 ">=" Exp6 ;
EEQ.			Exp4			::= Exp4 "==" Exp5 ;
ENEQ.			Exp4			::= Exp4 "!=" Exp5 ;
EAND.			Exp3			::= Exp3 "&&" Exp4 ;
EOR.			Exp2			::= Exp2 "||" Exp3 ;
ECase.          Exp1            ::= "case" Exp "of" Cases ;
EIf.            Exp1            ::= "if" Exp2 "then" Exp2 "else" Exp ;
EAbs.			Exp1			::= "\\" Id "->" Exp ;
coercions Exp 10 ;
separator Exp "," ;

-- Structure for case expressions
ECases1.		Cases			::= CArg "->" Exp ";" Cases1 ;
ECases2.		Cases1			::= CArg "->" Exp ";" Cases1 ;
ECases3.		Cases1			::= ;

-- Arguments for the case expression
CCArg1.			CArg			::= Pat ;
CCArg2.			CArg			::= ListPattern ;
CCArg3.			CArg			::= Tuple ;

-- Structure of list comprehensions input set(s) and predicates.
-- The elements drawn from the input set are either bound 
-- to an identifier or a wild-card.
ELCPatterns1.	LCPatterns		::= Pat "<-" Id ;
ELCPatterns2.	LCPatterns		::= Pat "<-" Id "," LCPatterns ;
ELCPatterns3.	LCPatterns		::= Pat "<-" Id "," Predicate ;
ELCPatterns4.	LCPatterns		::= Pat "<-" "[" [Literal] "]" ;
ELCPatterns5.	LCPatterns		::= Pat "<-" "[" [Literal] "]" "," LCPatterns ;
ELCPatterns6.	LCPatterns		::= Pat "<-" "[" [Literal] "]" "," Predicate ;
separator nonempty Literal "," ;
LCPredicate.	Predicate		::= Exp ;
LCPredicates.	Predicate		::= Exp "," Predicate ;

-- Let bindings, this is requires an additional ';' at the very end of the binding.
ELetBinding1.	LetBinding		::= "let" [LetBinding1] "in" Exp ";" ;
ELetBinding2.	LetBinding1		::= Id ":=" Exp ;
terminator nonempty LetBinding1 ";" ;

-- Types, either regular or linear
TTypeId.		Type		    ::= TypeId ;
TList.          Type            ::= "[" [Type] "]" ;
TTuple.         Type            ::= "(" [Type] ")" ;
separator Type "," ;

-- Haskell-style comments for now
comment "--" ;
comment "{-" "-}" ;